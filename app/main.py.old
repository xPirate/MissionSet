import os
import json
import re
from uuid import uuid4
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Set

from fastapi import FastAPI, Request, Form, HTTPException, File, UploadFile
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from starlette.middleware.sessions import SessionMiddleware

from sqlalchemy import create_engine, text
from passlib.hash import bcrypt

from opensearchpy import OpenSearch

# ---- Config ----
OS_HOST = os.getenv("OS_HOST", "localhost")
OS_PORT = int(os.getenv("OS_PORT", "9200"))
OS_INDEX = os.getenv("OS_INDEX", "missionset-data")
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./data.db")
SECRET_KEY = os.getenv("SECRET_KEY", "CHANGE_ME_SECRET")

ALLOWED_LABELS = ["Recon", "Mission", "Medical", "Emergency", "Notice"]

# New: allow-list for blood types (blank allowed for no fill)
BLOOD_TYPES = ["", "A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"]


# New: allow-list for blood types (blank allowed for no fill)
BLOOD_TYPES = ["", "A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"]


# New: allow-list for blood types (blank allowed for no fill)
BLOOD_TYPES = ["", "A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"]


# New: allow-list for blood types (blank allowed for no fill)
BLOOD_TYPES = ["", "A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"]


# ---- Branding (env-driven + file override) ----
BRAND_FILE = os.getenv("BRAND_FILE", "./branding.json")
BRAND_NAME = os.getenv("BRAND_NAME", "MissionSet")
BRAND_TAGLINE = os.getenv("BRAND_TAGLINE", "Secure reporting and ops hub")
BRAND_LOGO_URL = os.getenv("BRAND_LOGO_URL", "")  # optional: absolute URL or /static/logo.png
BRAND_PRIMARY = os.getenv("BRAND_PRIMARY", "#6366F1")  # accent color
BRAND_FOOTER_LINK_TEXT = os.getenv("BRAND_FOOTER_LINK_TEXT", "GitHub: xPirate/MissionSet")
BRAND_FOOTER_LINK_URL = os.getenv("BRAND_FOOTER_LINK_URL", "https://github.com/xPirate/MissionSet")

BRAND = {
    "name": BRAND_NAME,
    "tagline": BRAND_TAGLINE,
    "logo_url": BRAND_LOGO_URL,
    "primary": BRAND_PRIMARY,
    "footer_text": BRAND_FOOTER_LINK_TEXT,
    "footer_url": BRAND_FOOTER_LINK_URL,
}

def _load_brand_file():
    global BRAND
    try:
        if os.path.exists(BRAND_FILE):
            with open(BRAND_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                BRAND.update({k: v for k, v in data.items() if k in BRAND})
    except Exception as e:
        print("Branding load error:", e)

def _save_brand_file(data: Dict[str, str]):
    global BRAND
    BRAND.update(data)
    try:
        with open(BRAND_FILE, "w", encoding="utf-8") as f:
            json.dump(BRAND, f, indent=2)
    except Exception as e:
        print("Branding save error:", e)

def _valid_hex_color(s: str) -> bool:
    return bool(re.fullmatch(r"#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})", (s or "").strip()))

_load_brand_file()

# ---- Profile requirements ----
REQUIRED_PROFILE_FIELDS = [
    "name", "birthday", "team", "team_role",
    "phone", "email", "contact_name", "contact_phone"
]

def profile_is_complete(p: dict) -> bool:
    for f in REQUIRED_PROFILE_FIELDS:
        if not (p.get(f) or "").strip():
            return False
    return True

# ---- App ----
app = FastAPI(title="MissionSet â€” Admin & Permissions")
app.add_middleware(SessionMiddleware, secret_key=SECRET_KEY, session_cookie="ms_session")
# Ensure static/uploads exists (for branding logo uploads)
os.makedirs("static/uploads", exist_ok=True)
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# ---- DB ----
engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {},
)

def init_db():
    with engine.begin() as conn:
        conn.exec_driver_sql(
            '''
            CREATE TABLE IF NOT EXISTS items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                description TEXT,
                tags TEXT,
                created_at TEXT NOT NULL,
                author TEXT,
                author_user_id INTEGER,
                start_time TEXT,
                end_time TEXT
            );
            '''
        )
        conn.exec_driver_sql(
            '''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                is_admin INTEGER NOT NULL DEFAULT 0,
                is_active INTEGER NOT NULL DEFAULT 1,
                created_at TEXT NOT NULL
            );
            '''
        )
        conn.exec_driver_sql(
            '''
            CREATE TABLE IF NOT EXISTS profiles (
                user_id INTEGER PRIMARY KEY,
                name TEXT NOT NULL DEFAULT '',
                birthday TEXT,
                blood_type TEXT,
                team TEXT,
                team_role TEXT,
                phone TEXT,
                email TEXT,
                contact_name TEXT,
                contact_phone TEXT,
                updated_at TEXT
            );
            '''
        )
        conn.exec_driver_sql(
            '''
            CREATE TABLE IF NOT EXISTS comments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                content TEXT NOT NULL,
                created_at TEXT NOT NULL
            );
            '''
        )
        conn.exec_driver_sql(
            '''
            CREATE TABLE IF NOT EXISTS label_permissions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                label TEXT NOT NULL,
                can_view INTEGER NOT NULL DEFAULT 1,
                can_create INTEGER NOT NULL DEFAULT 1,
                UNIQUE(user_id, label)
            );
            '''
        )
init_db()

# ---- OpenSearch ----
os_client = OpenSearch(
    hosts=[{"host": OS_HOST, "port": OS_PORT}],
    http_compress=True,
    use_ssl=False,
    verify_certs=False,
)

def ensure_index():
    try:
        if not os_client.indices.exists(index=OS_INDEX):
            os_client.indices.create(
                index=OS_INDEX,
                body={
                    "settings": {"index": {"number_of_shards": 1, "number_of_replicas": 0}},
                    "mappings": {
                        "properties": {
                            "title": {"type": "text"},
                            "description": {"type": "text"},
                            "tags": {"type": "keyword"},
                            "author": {"type": "keyword"},
                            "start_time": {"type": "date"},
                            "end_time": {"type": "date"},
                            "created_at": {"type": "date"},
                        }
                    },
                },
            )
    except Exception as e:
        print("OpenSearch index init error:", e)

ensure_index()

# ---- Helpers ----
def row_to_dict(row): return dict(row._mapping) if row else None

def split_tags(tag_str: Optional[str]) -> List[str]:
    if not tag_str: return []
    return [t.strip() for t in tag_str.split(",") if t.strip()]

def current_user(request: Request) -> Optional[Dict]:
    uid = request.session.get("user_id")
    if not uid: return None
    with engine.connect() as conn:
        row = conn.execute(text("SELECT * FROM users WHERE id = :id AND is_active=1"), {"id": uid}).first()
    return row_to_dict(row) if row else None

def get_profile(uid: int) -> Dict:
    with engine.connect() as conn:
        row = conn.execute(text("SELECT * FROM profiles WHERE user_id = :id"), {"id": uid}).first()
    return row_to_dict(row) or {
        "user_id": uid, "name": "", "birthday": "", "blood_type": "", "team": "", "team_role": "",
        "phone": "", "email": "", "contact_name": "", "contact_phone": ""
    }

def ctx(request: Request, extra: Dict=None) -> Dict:
    u = current_user(request)
    p = get_profile(u["id"]) if u else None
    base = {"request": request, "user": u, "profile": p, "ALLOWED_LABELS": ALLOWED_LABELS, "BRAND": BRAND}
    if extra: base.update(extra)
    return base

def require_login(request: Request) -> Dict:
    u = current_user(request)
    if not u:
        next_path = request.url.path or "/"
        raise HTTPException(status_code=303, headers={"Location": f"/auth/login?next={next_path}"})
    return u

def get_last_n_days(n: int):
    today = datetime.utcnow().date()
    return [(today - timedelta(days=i)).isoformat() for i in range(n - 1, -1, -1)]

def parse_dt(s: str, field: str) -> datetime:
    try:
        return datetime.fromisoformat(s)
    except Exception:
        raise HTTPException(status_code=400, detail=f"Invalid datetime for {field}")

def split_first_last(full: Optional[str]):
    full = (full or "").strip()
    if not full:
        return "", ""
    parts = full.split()
    if len(parts) == 1:
        return parts[0], ""
    return parts[0], " ".join(parts[1:])

# ----- Permissions (view/create per label) -----
def user_allowed_labels(u: Optional[Dict], mode: str) -> Set[str]:
    if not u:
        return set()
    if u.get("is_admin"):
        return set(ALLOWED_LABELS)
    with engine.connect() as conn:
        rows = conn.execute(text("SELECT label, can_view, can_create FROM label_permissions WHERE user_id=:uid"),
                            {"uid": u["id"]}).all()
    if not rows:
        return set(ALLOWED_LABELS)
    allowed = set()
    for r in rows:
        if mode == "view" and r._mapping["can_view"]:
            allowed.add(r._mapping["label"])
        if mode == "create" and r._mapping["can_create"]:
            allowed.add(r._mapping["label"])
    return allowed

def can_view_item(u: Optional[Dict], item: Dict) -> bool:
    if not item: return False
    if u and (u.get("is_admin") or u["id"] == item.get("author_user_id")):
        return True
    tags = split_tags(item.get("tags"))
    if not tags:
        return True
    allowed = user_allowed_labels(u, "view")
    return bool(set(tags) & allowed)

def index_item_in_os(item_id: int, item: Dict):
    try:
        os_client.index(
            index=OS_INDEX,
            id=str(item_id),
            body={
                "title": item["title"],
                "description": item.get("description") or "",
                "tags": split_tags(item.get("tags")),
                "author": item.get("author") or "",
                "start_time": item.get("start_time"),
                "end_time": item.get("end_time"),
                "created_at": item["created_at"],
            },
            refresh=True,
        )
    except Exception as e:
        print("OpenSearch index error:", e)

# ---- Root / Landing / Dashboard ----
@app.get("/", response_class=HTMLResponse)
def root(request: Request):
    u = current_user(request)
    if not u:
        with engine.connect() as conn:
            count = conn.execute(text("SELECT COUNT(*) AS c FROM users")).scalar_one()
        return templates.TemplateResponse(
            "landing.html",
            ctx(request, {"allow_register": count == 0, "active_tab": "login", "error": None, "next_url": request.query_params.get("next")})
        )
    return templates.TemplateResponse("index.html", ctx(request, compute_dashboard_stats(u)))

# ---- Auth ----
@app.get("/auth/login", response_class=HTMLResponse)
def login_form(request: Request, next: str = ""):
    with engine.connect() as conn:
        count = conn.execute(text("SELECT COUNT(*) AS c FROM users")).scalar_one()
    return templates.TemplateResponse(
        "landing.html",
        ctx(request, {"allow_register": count == 0, "active_tab": "login", "error": None, "next_url": next})
    )

@app.post("/auth/login")
def login_submit(
    request: Request,
    username: str = Form(...),
    password: str = Form(...),
    next: str = Form(default="")
):
    with engine.connect() as conn:
        row = conn.execute(text("SELECT * FROM users WHERE username = :u AND is_active=1"), {"u": username}).first()
    user = row_to_dict(row) if row else None
    if not user or not bcrypt.verify(password, user["password_hash"]):
        with engine.connect() as conn:
            count = conn.execute(text("SELECT COUNT(*) AS c FROM users")).scalar_one()
        return templates.TemplateResponse(
            "landing.html",
            ctx(request, {"allow_register": count == 0, "active_tab": "login", "error": "Invalid credentials", "next_url": next}),
            status_code=401
        )

    request.session["user_id"] = user["id"]

    # Force profile completion on first login
    prof = get_profile(user["id"])
    if not profile_is_complete(prof):
        return RedirectResponse(url="/profile?first=1", status_code=303)

    redirect_to = next if (next and next.startswith("/")) else "/"
    return RedirectResponse(url=redirect_to, status_code=303)

@app.post("/auth/logout")
def logout(request: Request):
    request.session.clear()
    return RedirectResponse(url="/auth/login", status_code=303)

@app.get("/auth/register", response_class=HTMLResponse)
def register_form(request: Request):
    with engine.connect() as conn:
        count = conn.execute(text("SELECT COUNT(*) AS c FROM users")).scalar_one()
    if count > 0:
        return RedirectResponse(url="/auth/login", status_code=303)
    return templates.TemplateResponse(
        "landing.html",
        ctx(request, {"allow_register": True, "active_tab": "register", "error": None, "next_url": "/"})
    )

@app.post("/auth/register")
def register_submit(
    request: Request,
    username: str = Form(...),
    password: str = Form(...),
    first_name: str = Form(...),
    last_name: str = Form(...)
):
    now = datetime.utcnow().isoformat()
    full_name = f"{first_name.strip()} {last_name.strip()}".strip()
    pwd = bcrypt.hash(password)

    with engine.begin() as conn:
        count = conn.execute(text("SELECT COUNT(*) AS c FROM users")).scalar_one()
        is_admin = 1 if count == 0 else 0
        try:
            conn.execute(
                text("INSERT INTO users (username, password_hash, is_admin, is_active, created_at) VALUES (:u,:p,:a,1,:c)"),
                {"u": username, "p": pwd, "a": is_admin, "c": now}
            )
        except Exception:
            return templates.TemplateResponse(
                "landing.html",
                ctx(request, {"allow_register": (count == 0), "active_tab": "register", "error": "Username already exists", "next_url": "/"}),
                status_code=400
            )

        uid = conn.execute(text("SELECT id FROM users WHERE username=:u"), {"u": username}).scalar_one()
        conn.execute(
            text("INSERT INTO profiles (user_id, name, updated_at) VALUES (:id,:n,:t) "
                 "ON CONFLICT(user_id) DO UPDATE SET name=:n, updated_at=:t"),
            {"id": uid, "n": full_name, "t": now}
        )
    return RedirectResponse(url="/auth/login", status_code=303)

# ---- Profile ----
@app.get("/profile", response_class=HTMLResponse)
def profile_form(request: Request):
    u = require_login(request)
    prof = get_profile(u["id"])
    first_time = request.query_params.get("first") == "1"
    return templates.TemplateResponse("profile.html", ctx(request, {"prof": prof, "first_time": first_time, "error": None}))

@app.post("/profile")
def profile_save(
    request: Request,
    name: str = Form(...),
    birthday: str = Form(""),
    blood_type: str = Form(""),
    team: str = Form(""),
    team_role: str = Form(""),
    phone: str = Form(""),
    email: str = Form(""),
    contact_name: str = Form(""),
    contact_phone: str = Form("")
):
    u = require_login(request)

    fields = {
        "user_id": u["id"],
        "name": name,
        "birthday": birthday,
        "blood_type": blood_type,
        "team": team,
        "team_role": team_role,
        "phone": phone,
        "email": email,
        "contact_name": contact_name,
        "contact_phone": contact_phone,
    }

    missing = [k for k in REQUIRED_PROFILE_FIELDS if not (fields.get(k) or "").strip()]
    if missing:
        return templates.TemplateResponse(
            "profile.html",
            ctx(request, {"prof": fields, "first_time": True, "error": "Please complete all required fields."}),
            status_code=400
        )

    now = datetime.utcnow().isoformat()
    with engine.begin() as conn:
        conn.execute(text('''
            INSERT INTO profiles (user_id, name, birthday, blood_type, team, team_role, phone, email, contact_name, contact_phone, updated_at)
            VALUES (:user_id, :name, :birthday, :blood_type, :team, :team_role, :phone, :email, :contact_name, :contact_phone, :t)
            ON CONFLICT(user_id) DO UPDATE SET
              name=:name, birthday=:birthday, blood_type=:blood_type, team=:team, team_role=:team_role,
              phone=:phone, email=:email, contact_name=:contact_name, contact_phone=:contact_phone, updated_at=:t
        '''), {**fields, "t": now})

    return RedirectResponse(url="/", status_code=303)

# ---- Admin root & Users tab ----
@app.get("/admin", response_class=HTMLResponse)
def admin_root(request: Request):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    return RedirectResponse(url="/admin/users", status_code=303)

@app.get("/admin/users", response_class=HTMLResponse)
def admin_users_tab(request: Request):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    with engine.connect() as conn:
        rows = conn.execute(text("""
            SELECT u.id, u.username, u.is_admin, u.is_active,
                   COALESCE(p.name,'') AS full_name, COALESCE(p.team,'') AS team,
                   COALESCE(p.team_role,'') AS team_role
            FROM users u
            LEFT JOIN profiles p ON p.user_id = u.id
            ORDER BY u.id ASC
        """)).all()
    users = []
    for r in rows:
        d = row_to_dict(r)
        first, last = split_first_last(d.get("full_name", ""))
        d["first_name"] = first
        d["last_name"] = last
        users.append(d)
    return templates.TemplateResponse("admin_users.html", ctx(request, {"users": users, "ADMIN_TAB": "users"}))

@app.get("/admin/user/{uid}", response_class=HTMLResponse)
def admin_user_detail(request: Request, uid: int):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")

    with engine.connect() as conn:
        ur = conn.execute(text("SELECT * FROM users WHERE id=:id"), {"id": uid}).first()
        if not ur: raise HTTPException(status_code=404, detail="User not found")
        pr = conn.execute(text("SELECT * FROM profiles WHERE user_id=:id"), {"id": uid}).first()
        perms = conn.execute(text("SELECT label, can_view, can_create FROM label_permissions WHERE user_id=:id"),
                             {"id": uid}).all()

    user = row_to_dict(ur)
    prof = row_to_dict(pr) or {}
    first, last = split_first_last(prof.get("name", ""))

    # Build permissions map with default-allow when no rows exist
    pmap = {lbl: {"view": 1, "create": 1} for lbl in ALLOWED_LABELS}
    if perms:
        # Start closed, open only where set
        pmap = {lbl: {"view": 0, "create": 0} for lbl in ALLOWED_LABELS}
        for row in perms:
            d = row_to_dict(row)
            lbl = d["label"]
            if lbl in pmap:
                pmap[lbl]["view"] = d["can_view"]
                pmap[lbl]["create"] = d["can_create"]

    payload = {
        "user": user,
        "profile": prof,
        "first_name": first,
        "last_name": last,
        "perm_map": pmap,
        "ALLOWED_LABELS": ALLOWED_LABELS,
        "ADMIN_TAB": "users",
    }
    return templates.TemplateResponse("admin_user_detail.html", ctx(request, payload))

@app.post("/admin/user/{uid}/permissions")
def admin_user_permissions_save(request: Request, uid: int, payload: str = Form(...)):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    try:
        data = json.loads(payload)  # {"Recon":{"view":1,"create":0}, ...}
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid submission")

    with engine.begin() as conn:
        # Replace upserts for each label
        for label, flags in data.items():
            if label not in ALLOWED_LABELS:
                continue
            cv = 1 if flags.get("view") else 0
            cc = 1 if flags.get("create") else 0
            conn.execute(text("""
                INSERT INTO label_permissions (user_id, label, can_view, can_create)
                VALUES (:u, :l, :cv, :cc)
                ON CONFLICT(user_id, label) DO UPDATE
                SET can_view=:cv, can_create=:cc
            """), {"u": uid, "l": label, "cv": cv, "cc": cc})

    return RedirectResponse(url=f"/admin/user/{uid}", status_code=303)

# ---- Admin: Branding tab ----
@app.get("/admin/branding", response_class=HTMLResponse)
def admin_branding_form(request: Request):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    # Always reload from file on view to reflect external edits
    _load_brand_file()
    return templates.TemplateResponse("admin_branding.html", ctx(request, {"ADMIN_TAB": "branding"}))

@app.post("/admin/branding", response_class=HTMLResponse)
def admin_branding_save(
    request: Request,
    name: str = Form(...),
    tagline: str = Form(...),
    primary: str = Form(...),
    footer_text: str = Form(...),
    footer_url: str = Form(...),
    logo_url: str = Form(""),
    logo_file: UploadFile = File(None)
):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")

    # Handle logo upload if provided
    final_logo_url = (logo_url or "").strip()
    if logo_file and logo_file.filename:
        ext = os.path.splitext(logo_file.filename)[1].lower()
        if ext not in [".png", ".jpg", ".jpeg", ".webp", ".gif"]:
            return templates.TemplateResponse("admin_branding.html", ctx(request, {"ADMIN_TAB": "branding", "error": "Unsupported logo format"}), status_code=400)
        fname = f"logo_{uuid4().hex}{ext}"
        dest = os.path.join("static", "uploads", fname)
        with open(dest, "wb") as f:
            f.write(logo_file.file.read())
        final_logo_url = f"/static/uploads/{fname}"

    # Validate color and footer URL basics
    if not _valid_hex_color(primary):
        return templates.TemplateResponse("admin_branding.html", ctx(request, {"ADMIN_TAB": "branding", "error": "Primary color must be a hex like #3B82F6"}), status_code=400)
    if not footer_url.startswith(("http://", "https://", "/")):
        return templates.TemplateResponse("admin_branding.html", ctx(request, {"ADMIN_TAB": "branding", "error": "Footer URL must start with http(s):// or /"}), status_code=400)

    updated = {
        "name": name.strip() or "MissionSet",
        "tagline": tagline.strip() or "Secure reporting and ops hub",
        "primary": primary.strip(),
        "footer_text": footer_text.strip() or "GitHub: xPirate/MissionSet",
        "footer_url": footer_url.strip() or "https://github.com/xPirate/MissionSet",
        "logo_url": final_logo_url,
    }
    _save_brand_file(updated)
    # Redirect to GET so refresh doesn't resubmit
    return RedirectResponse(url="/admin/branding", status_code=303)

# ---- Existing admin helpers (new user, toggles) ----
@app.get("/admin/users/new", response_class=HTMLResponse)
def admin_users_new_form(request: Request):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    return templates.TemplateResponse("admin_user_new.html", ctx(request, {"error": None}))

@app.post("/admin/users/new")
def admin_users_new(request: Request, username: str = Form(...), password: str = Form(...), name: str = Form(...), is_admin: int = Form(0)):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    now = datetime.utcnow().isoformat()
    pwd = bcrypt.hash(password)
    with engine.begin() as conn:
        try:
            conn.execute(text("INSERT INTO users (username,password_hash,is_admin,is_active,created_at) VALUES (:u,:p,:a,1,:c)"),
                         {"u": username, "p": pwd, "a": 1 if is_admin else 0, "c": now})
        except Exception:
            return templates.TemplateResponse("admin_user_new.html", ctx(request, {"error": "Username exists"}), status_code=400)
        uid = conn.execute(text("SELECT id FROM users WHERE username=:u"), {"u": username}).scalar_one()
        conn.execute(text("INSERT INTO profiles (user_id,name,updated_at) VALUES (:id,:n,:t)"), {"id": uid, "n": name, "t": now})
    return RedirectResponse(url="/admin/users", status_code=303)

@app.post("/admin/users/{uid}/toggle_admin")
def admin_toggle_admin(request: Request, uid: int):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    with engine.begin() as conn:
        conn.execute(text("UPDATE users SET is_admin = 1 - is_admin WHERE id = :id"), {"id": uid})
    return RedirectResponse(url="/admin/users", status_code=303)

@app.post("/admin/users/{uid}/toggle_active")
def admin_toggle_active(request: Request, uid: int):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    with engine.begin() as conn:
        conn.execute(text("UPDATE users SET is_active = 1 - is_active WHERE id = :id"), {"id": uid})
    return RedirectResponse(url="/admin/users", status_code=303)

# ---- Dashboard helpers ----
def compute_dashboard_stats(u: Optional[Dict]) -> Dict[str, object]:
    viewable = user_allowed_labels(u, "view") if u and not u.get("is_admin") else set(ALLOWED_LABELS)
    with engine.connect() as conn:
        rows = conn.execute(text("SELECT id, title, tags, created_at FROM items ORDER BY id DESC LIMIT 50")).all()
    filtered = []
    for r in rows:
        d = row_to_dict(r)
        if can_view_item(u, d):
            filtered.append(d)
        if len(filtered) >= 5:
            break

    with engine.connect() as conn:
        tag_rows = conn.execute(text("SELECT COALESCE(tags,'') AS tags FROM items")).all()
        days = get_last_n_days(5)
        min_d, max_d = days[0], days[-1]
        day_rows = conn.execute(text("""
            SELECT substr(created_at,1,10) AS d, tags AS tags
            FROM items
            WHERE substr(created_at,1,10) >= :min_d AND substr(created_at,1,10) <= :max_d
        """), {"min_d": min_d, "max_d": max_d}).all()

    label_counts = {l: 0 for l in ALLOWED_LABELS}
    unlabeled = 0
    for r in tag_rows:
        tags = split_tags(r._mapping["tags"])
        if not tags:
            unlabeled += 1
            continue
        matched_any = False
        for t in tags:
            if t in label_counts:
                if (t in viewable) or (u and u.get("is_admin")):
                    label_counts[t] += 1
                    matched_any = True
        if not matched_any:
            unlabeled += 1

    total = sum(label_counts.values()) + unlabeled
    if total == 0:
        pie_labels, pie_values = ["No data"], [1]
    else:
        pie_labels = list(label_counts.keys()) + (["Unlabeled"] if unlabeled else [])
        pie_values = list(label_counts.values()) + ([unlabeled] if unlabeled else [])

    days = get_last_n_days(5)
    day_map = {d: 0 for d in days}
    for r in day_rows:
        d = r._mapping["d"]
        tags = split_tags(r._mapping["tags"])
        if not tags:
            day_map[d] += 1
        elif any(t in viewable for t in tags) or (u and u.get("is_admin")):
            day_map[d] += 1

    return {
        "recent": filtered,
        "pie_labels_json": json.dumps(pie_labels),
        "pie_values_json": json.dumps(pie_values),
        "line_labels_json": json.dumps(days),
        "line_values_json": json.dumps([day_map[d] for d in days]),
    }

# ---- Reports CRUD ----
@app.get("/data", response_class=HTMLResponse)
def list_items(request: Request):
    u = require_login(request)
    with engine.connect() as conn:
        rows = conn.execute(text("""
            SELECT id, title, description, tags, created_at, author, author_user_id, start_time, end_time
            FROM items ORDER BY id DESC
        """)).all()
    all_items = [row_to_dict(r) for r in rows]
    items = [it for it in all_items if can_view_item(u, it)]
    return templates.TemplateResponse("data.html", ctx(request, {"items": items}))

@app.get("/data/new", response_class=HTMLResponse)
def new_item_form(request: Request):
    u = require_login(request)
    prof = get_profile(u["id"])
    creatable = sorted(list(user_allowed_labels(u, "create"))) if not u.get("is_admin") else ALLOWED_LABELS
    return templates.TemplateResponse("new.html", ctx(request, {"current_user_name": prof.get("name") or u["username"], "CREATE_LABELS": creatable}))

def enforce_labels_subset(u: Dict, labels: List[str]):
    allowed = user_allowed_labels(u, "create") if not u.get("is_admin") else set(ALLOWED_LABELS)
    for l in labels:
        if l not in allowed:
            raise HTTPException(status_code=403, detail=f"No create permission for label: {l}")

@app.post("/data/new")
def create_item(
    request: Request,
    title: str = Form(...),
    start_time: str = Form(...),
    end_time: str = Form(...),
    description: str = Form(""),
    labels: List[str] = Form([]),
):
    u = require_login(request)
    prof = get_profile(u["id"])
    author = prof.get("name") or u["username"]
    labels = [l for l in labels if l in ALLOWED_LABELS]
    enforce_labels_subset(u, labels if labels else [])
    created_at = datetime.utcnow().isoformat()
    sdt, edt = parse_dt(start_time, "start_time"), parse_dt(end_time, "end_time")
    if edt < sdt:
        return templates.TemplateResponse(
            "new.html",
            ctx(request, {"current_user_name": author, "CREATE_LABELS": sorted(list(user_allowed_labels(u, 'create'))), "error": "End time must be after start time"}),
            status_code=400,
        )

    with engine.begin() as conn:
        try:
            item_id = conn.execute(text("""
                INSERT INTO items (title, description, tags, created_at, author, author_user_id, start_time, end_time)
                VALUES (:t,:d,:g,:c,:a,:uid,:s,:e) RETURNING id
            """), {"t": title, "d": description, "g": ",".join(labels), "c": created_at, "a": author, "uid": u["id"], "s": start_time, "e": end_time}).scalar_one()
        except Exception:
            conn.execute(text("""
                INSERT INTO items (title, description, tags, created_at, author, author_user_id, start_time, end_time)
                VALUES (:t,:d,:g,:c,:a,:uid,:s,:e)
            """), {"t": title, "d": description, "g": ",".join(labels), "c": created_at, "a": author, "uid": u["id"], "s": start_time, "e": end_time})
            item_id = conn.execute(text("SELECT last_insert_rowid()")).scalar_one()
        row = conn.execute(text("SELECT * FROM items WHERE id=:id"), {"id": item_id}).first()
    index_item_in_os(item_id, row_to_dict(row))
    return RedirectResponse(url=f"/data/{item_id}", status_code=303)

@app.get("/data/{item_id}", response_class=HTMLResponse)
def view_item(request: Request, item_id: int):
    u = require_login(request)
    with engine.connect() as conn:
        row = conn.execute(text("SELECT * FROM items WHERE id = :id"), {"id": item_id}).first()
        if not row: raise HTTPException(status_code=404, detail="Not found")
        comments = conn.execute(text("""
            SELECT c.*, COALESCE(p.name, u.username) AS author_name
            FROM comments c JOIN users u ON u.id=c.user_id LEFT JOIN profiles p ON p.user_id=u.id
            WHERE c.item_id=:id ORDER BY c.id ASC
        """), {"id": item_id}).all()
    item = row_to_dict(row)
    if not can_view_item(u, item): raise HTTPException(status_code=403, detail="Not allowed")
    comms = [row_to_dict(c) for c in comments]
    can_delete = bool(u and (u.get("is_admin") or u["id"] == item.get("author_user_id")))
    return templates.TemplateResponse("item.html", ctx(request, {"item": item, "comments": comms, "can_delete": can_delete}))

@app.get("/data/{item_id}/edit", response_class=HTMLResponse)
def edit_item_form(request: Request, item_id: int):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    with engine.connect() as conn:
        row = conn.execute(text("SELECT * FROM items WHERE id=:id"), {"id": item_id}).first()
    return templates.TemplateResponse("edit.html", ctx(request, {"item": row_to_dict(row), "error": None}))

@app.post("/data/{item_id}/edit")
def edit_item_submit(request: Request, item_id: int,
    title: str = Form(...),
    start_time: str = Form(...),
    end_time: str = Form(...),
    description: str = Form(""),
    labels: List[str] = Form([]),
):
    u = require_login(request)
    if not u.get("is_admin"): raise HTTPException(status_code=403, detail="Admin required")
    labels = [l for l in labels if l in ALLOWED_LABELS]
    sdt, edt = parse_dt(start_time, "start_time"), parse_dt(end_time, "end_time")
    if edt < sdt:
        return templates.TemplateResponse("edit.html", ctx(request, {"item": {"id": item_id, "title": title, "description": description, "tags": ",".join(labels), "start_time": start_time, "end_time": end_time}, "error": "End time must be after start time"}), status_code=400)
    with engine.begin() as conn:
        conn.execute(text("UPDATE items SET title=:t, description=:d, tags=:g, start_time=:s, end_time=:e WHERE id=:id"),
                     {"t": title, "d": description, "g": ",".join(labels), "s": start_time, "e": end_time, "id": item_id})
        row = conn.execute(text("SELECT * FROM items WHERE id=:id"), {"id": item_id}).first()
    index_item_in_os(item_id, row_to_dict(row))
    return RedirectResponse(url=f"/data/{item_id}", status_code=303)

@app.post("/data/{item_id}/delete")
def delete_item(request: Request, item_id: int):
    u = require_login(request)
    with engine.connect() as conn:
        row = conn.execute(text("SELECT author_user_id FROM items WHERE id=:id"), {"id": item_id}).first()
    if not row: raise HTTPException(status_code=404, detail="Not found")
    owner = row._mapping["author_user_id"]
    if not (u.get("is_admin") or u["id"] == owner):
        raise HTTPException(status_code=403, detail="Not allowed")
    with engine.begin() as conn:
        conn.execute(text("DELETE FROM items WHERE id=:id"), {"id": item_id})
        conn.execute(text("DELETE FROM comments WHERE item_id=:id"), {"id": item_id})
    try: os_client.delete(index=OS_INDEX, id=str(item_id), ignore=[404])
    except Exception: pass
    return RedirectResponse(url="/data", status_code=303)

# ---- Comments ----
@app.post("/data/{item_id}/comment")
def add_comment(request: Request, item_id: int, content: str = Form(...)):
    u = require_login(request)
    now = datetime.utcnow().isoformat()
    with engine.begin() as conn:
        conn.execute(text("INSERT INTO comments (item_id, user_id, content, created_at) VALUES (:i,:u,:c,:t)"),
                     {"i": item_id, "u": u["id"], "c": content, "t": now})
    return RedirectResponse(url=f"/data/{item_id}", status_code=303)

# ---- Modules ----
def normalize_label(label: str) -> str:
    cap = label.capitalize()
    if cap not in ALLOWED_LABELS: raise HTTPException(status_code=404, detail="Unknown module")
    return cap

@app.get("/module/{label}", response_class=HTMLResponse)
def module_page(request: Request, label: str):
    u = require_login(request)
    label = normalize_label(label)
    if label not in user_allowed_labels(u, "view") and not u.get("is_admin"):
        raise HTTPException(status_code=403, detail="No view permission for this label")
    with engine.connect() as conn:
        rows = conn.execute(text("SELECT id, title, author, created_at, start_time, end_time, tags FROM items WHERE ','||tags||',' LIKE :needle ORDER BY id DESC"),
                            {"needle": f"%,{label},%"}).all()
    items = [row_to_dict(r) for r in rows]
    prof = get_profile(u["id"])
    can_create = (label in user_allowed_labels(u, "create")) or u.get("is_admin")
    return templates.TemplateResponse("module.html", ctx(request, {"label": label, "items": items, "current_user_name": (prof.get('name') if prof else ''), "can_create": can_create}))

@app.post("/module/{label}/new")
def module_create(
    request: Request,
    label: str,
    title: str = Form(...),
    start_time: str = Form(...),
    end_time: str = Form(...),
    description: str = Form(""),
):
    u = require_login(request)
    label = normalize_label(label)
    if (label not in user_allowed_labels(u, "create")) and not u.get("is_admin"):
        raise HTTPException(status_code=403, detail="No create permission for this label")
    prof = get_profile(u["id"])
    author = prof.get("name") or u["username"]
    sdt, edt = parse_dt(start_time, "start_time"), parse_dt(end_time, "end_time")
    if edt < sdt:
        return templates.TemplateResponse("module.html", ctx(request, {"label": label, "items": [], "current_user_name": author, "can_create": True, "error": "End time must be after start time"}), status_code=400)
    created_at = datetime.utcnow().isoformat()
    with engine.begin() as conn:
        try:
            item_id = conn.execute(text("""
                INSERT INTO items (title, description, tags, created_at, author, author_user_id, start_time, end_time)
                VALUES (:t,:d,:g,:c,:a,:uid,:s,:e) RETURNING id
            """), {"t": title, "d": description, "g": label, "c": created_at, "a": author, "uid": u["id"], "s": start_time, "e": end_time}).scalar_one()
        except Exception:
            conn.execute(text("""
                INSERT INTO items (title, description, tags, created_at, author, author_user_id, start_time, end_time)
                VALUES (:t,:d,:g,:c,:a,:uid,:s,:e)
            """), {"t": title, "d": description, "g": label, "c": created_at, "a": author, "uid": u["id"], "s": start_time, "e": end_time})
            item_id = conn.execute(text("SELECT last_insert_rowid()")).scalar_one()
        row = conn.execute(text("SELECT * FROM items WHERE id=:id"), {"id": item_id}).first()
    index_item_in_os(item_id, row_to_dict(row))
    return RedirectResponse(url=f"/data/{item_id}", status_code=303)

# ---- Search (filtered by viewable labels) ----
@app.get("/search", response_class=HTMLResponse)
def search(request: Request, q: Optional[str] = None):
    u = require_login(request)
    results, err = [], None
    if q:
        allowed = list(user_allowed_labels(u, "view")) if not u.get("is_admin") else ALLOWED_LABELS
        try:
            body = {
                "query": {
                    "bool": {
                        "must": {"multi_match": {"query": q, "fields": ["title^2", "description", "author"]}},
                        "filter": [{"terms": {"tags": allowed}}] if allowed else []
                    }
                }
            }
            resp = os_client.search(index=OS_INDEX, body=body)
            for hit in resp.get("hits", {}).get("hits", []):
                src = hit.get("_source", {})
                results.append({"id": hit.get("_id"), "title": src.get("title"), "tags": ", ".join(src.get("tags", []) or []), "created_at": src.get("created_at")})
        except Exception as e:
            err = str(e)
    return templates.TemplateResponse("search.html", ctx(request, {"q": q or "", "results": results, "error": err}))
